Net: op_alu_i

High-Level Event: An instruction requires the ALU to perform an arithmetic or logical operation.

Logical Summary & Reasoning:  
The signal `op_alu_i` indicates whether the current instruction in the pipeline demands ALU operation. It is logically asserted when the instruction opcode matches any from a defined set of ALU-related operations (e.g., arithmetic or logical instructions). The signal is deasserted if the pipeline is being flushed, the processor is in reset, or a bubble (pipeline stall) is inserted, ensuring that no spurious ALU operations occur during these conditions. This reflects the architectural intent that the instruction in the decode/execute stage will engage the ALU for computation.

Test-Stimulus Guidance:  
To provoke this event at the ISA level, software should include instructions performing arithmetic or logical computations such as additions, subtractions, bitwise AND/OR/XOR, or comparisons. Typical C code generating these would include expressions using `+`, `-`, `&`, `|`, `^`, or conditional expressions that translate into ALU instructions upon compilation.

Instruction Categories:  
- Arithmetic instructions (e.g., add, subtract, multiply)  
- Logical instructions (e.g., AND, OR, XOR, NOT)  
- Comparison and test instructions (e.g., set-if-less, equality test)  
- Shift and rotate instructions (if they are implemented as ALU ops)

Net: op_cmov

High-Level Event: Execution of a conditional move instruction.

Logical Summary & Reasoning:  
The signal `op_cmov` is asserted when the processor decodes and executes an ALU operation identified as opcode `0xE` in the ALU instruction set, specifically when the ALU operation flag is active. This corresponds to a conditional move instruction, which conditionally transfers data from one register to another based on a predicate or condition. The signal is derived from instruction decode outputs that recognize specific opcode patterns associated with conditional moves, ensuring it activates only during the execution stage of such instructions. This event reflects the processorâ€™s initiation of a data transfer that depends on runtime conditions rather than unconditional moves.

Test-Stimulus Guidance:  
To provoke this event in software, write C code that uses conditional move semantics or equivalent constructs. This can be done by compiling high-level conditional assignments, such as `x = (condition) ? y : x;` or by explicitly using inline assembly with conditional move instructions if supported. The key is to create instructions that perform data moves contingent on flags or predicates without branching, often used for reducing branch mispredictions or optimizing small conditional data transfers.

Instruction Categories:  
- Conditional move instructions (conditional register-to-register transfer)  
- Predicated instructions that depend on flags or condition codes  
- ALU operations that incorporate conditional logic for data selection

Net: op_div_i

High-Level Event: Execution of a division operation instruction.

Logical Summary & Reasoning:  
The signal op_div_i is asserted when the processor's decode stage identifies the current instruction as a division operation, either signed or unsigned. This is derived from the logical OR of signals indicating signed or unsigned division decoded from the instruction opcode. The signal is reset to zero during pipeline flushes, resets, or decode bubbles to prevent false triggering. Its role is to indicate that the current instruction requires a division operation to be executed in the ALU stage, enabling the pipeline to route operands and control signals accordingly.

Test-Stimulus Guidance:  
To provoke this event, software should include instructions performing division operations. In C, this can be triggered by integer division expressions (e.g., `a = b / c;` or `a = b % c;`), especially with variables of signed or unsigned integer types. Using division instructions explicitly causes the processor to recognize and execute a division operation, activating this signal.

Instruction Categories:  
Integer division instructions, including signed division, unsigned division, and remainder/modulo operations, are the primary categories influencing this signal. These typically include divide and divide remainder instructions.

Net: op_div_signed_i

High-Level Event: Execution of a signed integer division instruction.

Logical Summary & Reasoning:  
The signal op_div_signed_i indicates whether the currently decoded instruction is a signed division operation. It is logically derived by decoding the instruction opcode and ALU operation fields to detect a signed division opcode pattern. This signal is cleared during pipeline flush, reset, or bubble conditions to prevent false triggering. Conceptually, it represents the processor recognizing and preparing to execute a signed division instruction at the decode stage, which will influence subsequent execution stages.

Test-Stimulus Guidance:  
To provoke this event, software should include signed integer division operations, such as dividing one signed integer variable by another using the division operator (e.g., `/` in C on signed integer types). Edge cases like division by negative numbers, division resulting in negative quotients, or division by -1 can further exercise the signed division execution path.

Instruction Categories:  
Integer arithmetic instructions involving division, specifically signed integer divide instructions. These include all instructions that perform division with signed operands and produce signed quotient results.

Net: op_div_unsigned_i

High-Level Event: The processor is executing an unsigned integer division instruction.

Logical Summary & Reasoning:  
This signal asserts when the current instruction decoded by the processor is identified as an unsigned division operation. The logic determining this involves checking that the instruction opcode matches the pattern corresponding to an unsigned divide instruction and that no reset, pipeline flush, or decode bubble conditions are active. This means the processor is actively processing an unsigned division instruction in the execute stage, aiming to perform a division operation treating operands as unsigned integers.

Test-Stimulus Guidance:  
To provoke this event in software, write C code that performs a division operation between two unsigned integer variables. For example, dividing one unsigned integer by another using the '/' operator will generate an unsigned division instruction at the ISA level. Edge cases such as division by zero or dividing by values that cause varying latency can also help trigger related processor behaviors involving unsigned division.

Instruction Categories:  
Instructions that perform unsigned arithmetic division on integer registers. This category includes any ISA-level instruction that divides unsigned integer operands and produces a quotient (and possibly remainder) visible to software. These are typically integer ALU instructions classified under unsigned divide operations.

Net: op_ext_i

High-Level Event: An instruction with an extended or custom operation encoding is being executed.

Logical Summary & Reasoning:  
The signal op_ext_i indicates whether the currently decoded instruction uses an extended or custom operation encoding beyond the base ISA. It is logically derived by checking if the instruction opcode matches a specific pattern combined with particular ALU operation codes and if an extension feature is enabled in the processor. This signal gates the selection of an extended operation variant, signifying that the instruction decoder has identified a non-standard or extension instruction that influences execution behavior at the ALU stage.

Test-Stimulus Guidance:  
To provoke this event, write C code that compiles into instructions using ISA extension or custom operations, such as specialized arithmetic or logic instructions not part of the base ISA. This could include using compiler intrinsics, inline assembly, or enabling optional ISA features that generate extended opcode instructions. These instructions typically perform operations like multiply-accumulate, bit-field manipulation, or cryptographic primitives.

Instruction Categories:  
Instructions that trigger this signal fall into categories involving ISA extensions or custom operations, such as arithmetic instructions with extended opcodes, special ALU operations beyond basic add/subtract/logic, and instructions introduced by optional architectural feature sets (e.g., multiply, divide, or custom instructions).

Net: op_ffl1_i

High-Level Event: Execution of a "find-first-set" bit instruction that scans an operand for the first bit set to one.

Logical Summary & Reasoning:  
The signal op_ffl1_i indicates the presence of an instruction that performs a bit-level scan to find the position of the first set (logical '1') bit in a source operand. This signal is asserted when the decoded instruction opcode matches a specific pattern associated with a "find-first-set" operation, confirmed by checking certain opcode fields and ALU operation codes. The signal is gated by pipeline control conditions such as reset, flush, and bubbles, ensuring it only asserts during valid instruction execution. Conceptually, this signal represents the execution phase recognition of a bit-scan instruction that produces a result indicating the index of the first set bit, a behavior visible at the architectural level.

Test-Stimulus Guidance:  
To provoke this event in software, write C code that includes instructions or compiler intrinsics performing bit scanning operations, such as finding the first set bit in an integer variable. This can be achieved using bit manipulation functions like __builtin_ffs or similar, or by coding loops that test bits sequentially. Using such operations on values with variable bit patterns, especially with only one or few bits set, will trigger the architectural behavior of executing a "find-first-set" instruction.

Instruction Categories:  
Bit manipulation instructions specifically designed for scanning bits (e.g., find-first-set, count-leading-zeros) fall into this category. These are typically arithmetic/logical instructions operating on registers or memory operands that produce bit position outputs. Instructions that generate flags or results based on bit patterns are also relevant.

Net: op_fpu_i

High-Level Event: Execution of a floating-point instruction.

Logical Summary & Reasoning:  
The signal op_fpu_i indicates that the current instruction being processed requires floating-point unit (FPU) involvement. This means the processor has decoded an instruction that performs floating-point arithmetic or related operations, triggering the FPU pipeline stage. The presence of this signal gates the activation of floating-point execution resources and dictates that the instruction semantics are related to floating-point computation rather than integer or other operations.

Test-Stimulus Guidance:  
To provoke this event, software should include floating-point operations such as addition, subtraction, multiplication, division, or comparisons on floating-point data types (e.g., `float` or `double`). Using floating-point arithmetic expressions or intrinsic functions that map to floating-point instructions will trigger the floating-point execution path signaled by op_fpu_i.

Instruction Categories:  
Floating-point arithmetic and logical instructions, including floating-point add, subtract, multiply, divide, compare, and conversions between floating-point and integer types.

Net: op_jbr_i

High-Level Event: Execution of a jump or branch instruction is signaled to control program flow.

Logical Summary & Reasoning:  
The signal op_jbr_i indicates whether the currently decoded instruction is a jump or branch type. It is derived from the instruction opcode decoding stage, confirming if the instruction falls into the jump/branch opcode category. This signal propagates through the pipeline stages unless reset, flushed, or stalled by bubbles, ensuring the processor accurately tracks control flow changes caused by jumps or branches at the earliest execute stage. Essentially, it flags an instruction that will alter the program counter by redirecting execution flow.

Test-Stimulus Guidance:  
To provoke this event in software, write C code that causes execution of control flow instructions such as unconditional jumps, conditional branches, or calls. Examples include loops with conditional branches (e.g., `if`, `while`), function calls and returns, or explicit goto statements. Using constructs that compile down to branch instructions will trigger the event, as these cause the processor to evaluate and potentially update the program counter non-sequentially.

Instruction Categories:  
Control flow instructions, specifically:  
- Unconditional jump instructions  
- Conditional branch instructions (e.g., branch if equal, branch if less)  
- Function call and return instructions that alter control flow

Net: op_jr_i

High-Level Event: Detection of an unconditional jump-register instruction triggering a control flow change.

Logical Summary & Reasoning:  
The signal op_jr_i reflects whether the currently decoded instruction is a jump-register type, identified by matching the opcode field to specific values representing jump-register operations. This signal is cleared on pipeline flush, reset, or decode bubble conditions, ensuring it only flags valid instructions in the decode/execute stage. Its role is to indicate that the processor must update the program counter based on a register's content, thus changing the control flow unconditionally. This event occurs at the decode/execute boundary where the processor recognizes the instruction type and prepares for the subsequent control transfer in the execution stage.

Test-Stimulus Guidance:  
To provoke this event, software should include instructions that perform indirect jumps via register values. In C, this can be achieved by implementing function pointers or computed gotos, or assembly inserts that execute indirect branch instructions. For example, using a function pointer call or switching execution to an address held in a register will cause the processor to recognize a jump-register instruction and trigger this event.

Instruction Categories:  
Control flow transfer instructions involving register-based jumps, such as indirect jumps or function returns (jump-register instructions), which cause the program counter to be loaded from a general-purpose register rather than an immediate address or PC-relative offset.

Net: op_logic

High-Level Event: Determination of ALU operation type signals that guide instruction execution behavior.

Logical Summary & Reasoning:  
The signal `op_logic` encodes a 4-bit code representing the logic function or operation the ALU will perform for the current instruction. It is derived from a prioritized selection among instruction classes: special register operations (move from/to special-purpose registers), ALU operations with specific sub-opcodes, or default behaviors when no ALU operation is present. The root gating signals are boolean indicators of instruction types (`op_mfspr_i`, `op_mtspr_i`, `op_alu_i`) and ALU sub-operation codes (`opc_alu_i`), combined in a priority-encoded manner. This signal abstracts the micro-architectural control that selects the arithmetic or logical operation applicable, impacting the execution stage where the instruction's functional effect is realized.

Test-Stimulus Guidance:  
To provoke changes in `op_logic`, software should include instructions that perform varied ALU operations such as logical AND, OR, XOR, addition, subtraction, and special register accesses. Writing C code with bitwise operations, arithmetic calculations, and explicit system or control register accesses will stimulate different values of this signal. For example, using bitwise AND/OR operations, arithmetic expressions, or inline assembly accessing control registers can trigger distinct ALU operation codes.

Instruction Categories:  
- ALU arithmetic instructions (add, subtract, multiply if present)  
- ALU logical instructions (AND, OR, XOR, NOT)  
- Special register move instructions (read/write system or special-purpose registers)  
- Non-ALU instructions that default to no logical operation (e.g., loads/stores, branches)

Net: op_mfspr_i

High-Level Event: Execution of a special-purpose register read instruction visible to software.

Logical Summary & Reasoning:  
The signal op_mfspr_i indicates when the processor is executing an instruction that reads from a special-purpose register (SPR). This signal is logically gated by reset, pipeline flush, pipeline advance, and decode stall conditions to ensure it correctly reflects valid instruction execution without interference from pipeline control events. Conceptually, it represents the processorâ€™s recognition that an SPR read instruction is in the execution stage, initiating architectural state changes visible at the ISA level by transferring SPR contents to a general-purpose register.

Test-Stimulus Guidance:  
To provoke this event, software can execute instructions that explicitly read from special-purpose or control registers. In C, these often correspond to inline assembly or intrinsic calls accessing processor control/status registers, performance counters, or other privileged registers. Triggering this event requires the instruction to successfully flow through the pipeline without stalls or flushes, so placing SPR reads after sequences that avoid exceptions, pipeline flushes, or stalls will reliably exercise this behavior.

Instruction Categories:  
Instructions that read from special-purpose or control registers (e.g., SPR read, system register read, control/status register access), typically privileged or system-level instructions that move data from processor internal registers to general-purpose registers.

Net: op_movhi_i

High-Level Event: Execution of a "load immediate high" instruction that sets the upper half of a register.

Logical Summary & Reasoning:  
The signal `op_movhi_i` indicates when the processor is executing an instruction that loads an immediate value into the upper half of a destination register. This is determined by decoding the instruction opcode matching a specific pattern corresponding to this high-immediate load operation. The signal is asserted only when the pipeline is not stalled, flushed, or reset, ensuring valid execution context. Conceptually, this signal marks the start of an instruction that updates a register's high-order bits with an immediate constant, which is a common ISA-level operation for constructing full-width constants in multiple steps.

Test-Stimulus Guidance:  
To provoke this event, software should include instructions that load immediate values into the upper half of registers. In C, this can be achieved by initializing or assigning large constants that do not fit into the lower half of a register, causing the compiler to emit instructions that set the high bits explicitly. For example, loading a 32-bit constant that requires setting upper 16 bits, or performing shifts combined with immediate loads to build full-width constants, will trigger this event. Writing code with explicit high-part immediate loads or manipulating large constants in variables is effective.

Instruction Categories:  
Instructions that load or move immediate values into the higher portion of a register, typically called "load high immediate," "move high immediate," or "set upper immediate" instructions. These belong to the category of immediate data movement instructions used in multi-instruction sequences to construct full-width constants from smaller immediate values.

Net: op_mtspr_i

High-Level Event: Execution of a privileged instruction writing to a special-purpose register.

Logical Summary & Reasoning:  
The signal `op_mtspr_i` indicates when the processor is executing a special instruction that updates a special-purpose register, typically a privileged control or status register. This event is gated by the decode and pipeline control logic to ensure it is valid only when the processor is not stalled, flushed, or in reset. The signal is effectively true when the instruction in the execute stage corresponds to an architectural operation that writes to a special register visible to software, and this operation is not suppressed by pipeline flushes, exceptions, or stalls. Thus, it represents the architectural phenomenon of a privileged register update instruction passing through the execution pipeline stage and affecting architectural state.

Test-Stimulus Guidance:  
Software can trigger this event by executing instructions that write to special-purpose registers or control/status registers, such as those configuring system control, timers, or debug facilities. In C, this can be done by using inline assembly or compiler intrinsics that access special registers, or by executing privileged instructions if running in an appropriate privilege mode. Test programs that perform context switching, interrupt handling setup, or manipulate processor state registers will provoke this event.

Instruction Categories:  
- Privileged control register write instructions (e.g., special register moves)  
- System configuration and control instructions  
- Instructions that modify processor status or control flags  
- Debug or performance monitoring register accesses  
- Exception or interrupt control instructions that write to special registers

Net: op_mul_i

High-Level Event: Execution of a multiplication instruction is active in the current pipeline stage.

Logical Summary & Reasoning:  
The signal indicates whether the processor is currently executing a multiply operation. It is asserted when the decoded instruction corresponds to either a signed or unsigned multiplication, provided the pipeline is not being reset, flushed, or stalled by a bubble. This signal reflects the active engagement of the execution stage with a multiplication instruction, signaling that multiply functional units or execution pathways are being utilized.

Test-Stimulus Guidance:  
To provoke this event, software should include explicit multiplication operations (e.g., using the â€˜*â€™ operator in C) on integer operands. Both signed and unsigned multiplication instructions will trigger this event. Writing code that includes multiplications with varying operand values, including edge cases like zero, positive, negative (for signed), and large values can ensure the multiply execution is exercised.

Instruction Categories:  
Integer arithmetic instructions involving multiplication, including signed multiply, unsigned multiply, and multiply-accumulate variants if present. These instructions directly influence this signal by requiring the processor to perform multiply operations in the execution stage.

Net: op_mul_signed_i

High-Level Event: Execution of a signed multiplication instruction.

Logical Summary & Reasoning:  
The signal `op_mul_signed_i` indicates whether the current instruction being executed is a signed multiply operation. It is derived from decoding the instruction opcode and ALU function fields to detect multiply instructions that require signed operand interpretation. This signal becomes active only when the pipeline is not being reset, flushed, or stalled by bubbles, ensuring it reflects valid instruction execution in the ALU stage. The role of this signal is to direct the processorâ€™s arithmetic logic to perform signed multiplication rather than unsigned or other operations, influencing how operand bits are interpreted and how the multiply operation is carried out.

Test-Stimulus Guidance:  
To trigger this event, software must execute multiplication operations where the operands are to be treated as signed integers. This can be achieved by writing C code that performs multiplication of signed integer variables (e.g., `int a = -3; int b = 7; int c = a * b;`). Using signed multiply instructions directly or through compiler intrinsics will ensure the processor decodes and executes a signed multiply operation, activating this signal.

Instruction Categories:  
- Signed multiplication instructions  
- Arithmetic instructions involving signed integer multiply operations  
- Instructions that differentiate operand signedness for multiply  
- ALU operations requiring signed operand interpretation

Net: op_mul_unsigned_i

High-Level Event: Execution of an unsigned integer multiplication instruction.

Logical Summary & Reasoning:  
This signal indicates whether the current instruction being executed is an unsigned multiply operation. It is derived by decoding the instruction opcode and ALU function fields to match the pattern corresponding to an unsigned multiplication. The signal is held low during reset, pipeline flushes, stalls, or bubbles, ensuring it only asserts when a valid, non-interrupted unsigned multiply instruction reaches the execution stage. Thus, it represents the processor recognizing and actively performing an unsigned multiply operation at the execution pipeline stage.

Test-Stimulus Guidance:  
To trigger this event in software, write C code that performs multiplication on unsigned integer variables. For example, multiplying two `unsigned int` values (e.g., `unsigned int a = 5; unsigned int b = 3; unsigned int c = a * b;`) will cause the processor to issue an unsigned multiply instruction. Avoid signed multiplication or mixed signedness to ensure the unsigned multiply operation is exercised.

Instruction Categories:  
Unsigned integer arithmetic instructions, specifically those that perform multiplication. This includes instructions that multiply two unsigned registers or immediate values, distinct from signed multiplication or other arithmetic operations such as addition, subtraction, or division.

Net: op_setflag_i

High-Level Event: An instruction signals that it will update the processorâ€™s condition or status flags as part of its execution.

Logical Summary & Reasoning:  
The signal op_setflag_i is asserted when the currently decoded instruction belongs to a specific subset of the ISA that performs status flag updatesâ€”specifically, instructions matching certain opcode patterns (e.g., arithmetic or logical operations that affect flags). The signal is gated off during reset, pipeline flush, or bubble insertion, ensuring only valid instructions trigger flag updates. This signal represents the intent of an instruction to modify architectural flags at the execute stage, abstracting away microarchitectural details and focusing on the instructionâ€™s architectural effect.

Test-Stimulus Guidance:  
To provoke this event in software, write instructions that perform arithmetic or logical operations which explicitly update the processor status flags. Examples include instructions that perform addition, subtraction, bitwise operations, or comparisons and update zero, carry, overflow, or sign flags. Using operations that set or clear flags based on the result (e.g., subtract-with-flag, compare, or arithmetic instructions with flag update variants) will trigger this event.

Instruction Categories:  
Arithmetic and logical instructions that optionally update condition flags, such as add, subtract, AND, OR, XOR, compare, and test instructions which have variants or modes that write back to the status register or condition flags.

Net: op_shift_i

High-Level Event: Execution of a shift operation instruction is recognized and flagged in the pipeline.

Logical Summary & Reasoning: The signal op_shift_i indicates whether the current instruction in the execute stage is a shift-type operation. It is logically derived from the instruction decode signals identifying specific opcode patterns corresponding to shift instructions. This signal is gated by reset, pipeline flush, and pipeline stall conditions to ensure it only asserts for valid, active instructions. Its role is to mark the presence of a shift operation being executed, enabling subsequent execution logic to perform the appropriate shift arithmetic or logical operation.

Test-Stimulus Guidance: To provoke this event, software should include instructions that perform bitwise shift operations, such as left shifts, right logical shifts, or right arithmetic shifts. In C, these are typically expressed using the shift operators (<<, >>) applied to integer types. Test code that exercises various shift amounts, including zero and maximum shifts, will activate this event.

Instruction Categories: Instructions that perform bitwise shifting on register operands, such as logical shifts (left and right) and arithmetic right shifts, fall into this category. These include shift immediate and shift register instructions found across RISC and CISC ISAs.

Net: opc_alu_ext

High-Level Event: Selection of an extended ALU operation variant for instruction execution.

Logical Summary & Reasoning:  
The signal `opc_alu_ext` encodes a secondary or extended ALU operation variant that modifies the primary ALU opcode to specify particular arithmetic or logical sub-operations. It is derived from decoding instruction bits related to ALU function extensions and conditionally altered based on instruction flags (e.g., set-flag presence) and pipeline state. This signal steers the ALU to perform a more precise operation beyond the base opcode, influencing the execution stage where the arithmetic or logical computation occurs. Thus, it represents a micro-architectural abstraction of the instructionâ€™s extended ALU operation intent.

Test-Stimulus Guidance:  
To provoke this event, software should include instructions that specify extended ALU operations or variants, such as instructions that conditionally modify flags, execute special arithmetic/logical sub-functions, or use instruction encodings that differentiate ALU behavior beyond a basic opcode. Examples include arithmetic instructions with flag update variants, shifts with specific modes, or logical operations with variant sub-operations. Writing C code that compiles to such instructions (e.g., arithmetic with condition codes, bit manipulation, or custom ALU ops) will trigger this signalâ€™s behavior.

Instruction Categories:  
Arithmetic instructions (add, sub, multiply variants), logical instructions (and, or, xor with variants), shift and rotate instructions, and instructions that conditionally modify status flags or perform specialized ALU sub-operations.

Net: opc_alu_i

High-Level Event:  
Selection of the ALU operation code defining the arithmetic or logical operation to be executed by the processor.

Logical Summary & Reasoning:  
The signal opc_alu_i represents the decoded ALU operation code that determines which arithmetic or logical function the execution unit will perform. It is derived from the instruction opcode bits after decoding, reflecting the instruction semantics rather than implementation details. The signal is set based on the current instructionâ€™s opcode fields, choosing among operations such as add, subtract, logical AND, OR, etc., or passing through defaults depending on instruction type or pipeline conditions. This selection directly controls the ALU operation in the execute stage, establishing the fundamental computation that affects architectural state (register file or flags).

Test-Stimulus Guidance:  
To provoke this event, software should include instructions that exercise a variety of ALU operations, such as integer arithmetic (add, subtract), logical bitwise operations (AND, OR, XOR), and shifts. Writing C code with expressions involving multiple arithmetic and logical operators, or inline assembly specifying different ALU instructions, will cause different ALU opcodes to be selected and exercised. For example, arithmetic expressions, bit manipulations, and comparisons can trigger the ALU to perform varied operations encoded by this signal.

Instruction Categories:  
- Arithmetic instructions (add, subtract, multiply if applicable)  
- Logical instructions (AND, OR, XOR, NOT)  
- Shift/rotate instructions (logical/arithmetic shifts, rotates)  
- Comparison instructions (set-less-than, test bits)  
- Move/immediate instructions that require ALU operations for address calculation or value manipulation

Net: opc_alu_secondary_i

High-Level Event: Selection of a secondary ALU operand source for the current instruction execution.

Logical Summary & Reasoning: The signal opc_alu_secondary_i determines which operand is forwarded as the secondary input to the ALU during instruction execution. Its value depends on the decoded instruction fields and pipeline control signals that select between a decoded immediate-like operand or a register destination field. This selection reflects the instruction semantics requiring either an immediate operand or a register-sourced operand for ALU operations. The signal gates the ALU input multiplexers to provide the correct operand at the execute stage, directly influencing the arithmetic or logical computation's correctness.

Test-Stimulus Guidance: Software can provoke this event by using instructions that perform ALU operations with different types of operands â€” for example, immediate arithmetic or logical instructions (e.g., add immediate, or immediate) versus register-register ALU operations. Writing C code that uses both immediate constants in expressions and operations between registers will trigger the alternation in secondary ALU operand selection.

Instruction Categories: ALU operations involving immediate operands (arithmetic or logical instructions with immediate values), and ALU operations involving two register operands (register-register arithmetic/logical instructions). This includes instructions that conditionally set flags based on the operation, influencing operand decoding.

Net: opc_alu_shr

High-Level Event: Execution of a shift-right ALU operation with a specified shift amount.

Logical Summary & Reasoning:  
The signal opc_alu_shr encodes the shift amount operand used by an ALU shift-right instruction. It is derived from instruction decode fields that specify the shift amount, possibly modified by pipeline stall or pad signals. This operand directly gates the ALU stage where the shift-right operation is performed, affecting the result of the instruction execution. The netâ€™s logic tracks the decoded shift amount field from the instruction word, which feeds into the ALU to perform a right-shift operation on a register operand. Thus, this signal represents the architectural operand controlling the magnitude of right-shifts executed by the processor.

Test-Stimulus Guidance:  
To provoke this event, software should include instructions performing right-shift operations on register values with varying shift amounts. In C, this corresponds to expressions using the right-shift operator (`>>`) on integer variables. Varying the shift amounts dynamically, including zero shifts, shifts equal to or exceeding the register width, and typical small shifts, will exercise the operand selection for shift-right ALU operations and trigger the associated event.

Instruction Categories:  
Instructions that perform logical or arithmetic right-shift operations, including immediate and register-based shift instructions. This category includes shift instructions that specify shift amounts either as immediate constants encoded in the instruction or via register operands, as well as related ALU instructions that use shift-right as part of their operation (e.g., rotate-right or combined bitwise operations involving shifts).

Net: overflow_clear_o

High-Level Event: Clearing the overflow flag after a signed arithmetic operation that did not generate an overflow or after a division not causing division-by-zero.

Logical Summary & Reasoning:  
This signal is active when the processorâ€™s overflow feature is enabled and a signed arithmetic instruction (addition, multiplication, or division) completes without triggering an exceptional condition. Specifically, it indicates that for a signed add or multiply, no signed overflow occurred, and for a signed division, no division-by-zero was detected. This netâ€™s purpose is to reset or clear the overflow indicator in the architectural state, ensuring that software-visible overflow flags accurately reflect the absence of overflow or division-by-zero exceptions after these operations.

Test-Stimulus Guidance:  
To provoke this event in software, execute signed arithmetic instructionsâ€”signed addition, signed multiplication, or signed divisionâ€”that produce valid results without exceeding the representable range or dividing by zero. Writing C code that performs signed arithmetic calculations guaranteed not to overflow or divide by zero will cause the processor to clear the overflow flag accordingly. For example, perform signed additions with operands well within limits, multiply small signed integers, or divide signed integers where the divisor is non-zero.

Instruction Categories:  
Signed arithmetic instructions that can affect overflow status, including:  
- Signed addition and subtraction instructions  
- Signed multiplication instructions  
- Signed division instructions

Net: overflow_set_o

High-Level Event: Detection of signed arithmetic overflow or division by zero during execution of arithmetic instructions.

Logical Summary & Reasoning:  
This signal asserts when a signed overflow occurs during addition, multiplication, or a division-by-zero condition is detected during signed division operations. It is logically gated by the type of arithmetic operation being performedâ€”addition, multiplication, or divisionâ€”and the presence of signed overflow or division-by-zero conditions associated with these operations. The signal represents an architectural event where the processor identifies that the result of a signed arithmetic instruction cannot be represented within the fixed operand width or that an illegal division (by zero) is attempted. This event typically arises during the execute stage where the ALU processes arithmetic instructions and checks for exceptional conditions affecting the correctness of result interpretation at the ISA level.

Test-Stimulus Guidance:  
To provoke this event in software, write C code that performs signed arithmetic operations capable of exceeding the representable range, such as adding two large positive or negative integers that cause signed overflow, or multiplying large signed operands that exceed the fixed width. Additionally, executing a signed division instruction where the divisor is zero will trigger the division-by-zero detection. For example, signed integer addition with operands pushing the limits of the signed integer range, signed multiplication of large magnitude operands, or division instructions with zero divisor will cause the architectural overflow or exception event.

Instruction Categories:  
- Signed integer addition and subtraction instructions  
- Signed integer multiplication instructions  
- Signed integer division instructions (including divide-by-zero detection)

Net: padv_decode_i

High-Level Event: Instruction decode stage is actively validating a new instruction for execution.

Logical Summary & Reasoning:  
The signal `padv_decode_i` is asserted when the processor fetch stage has a valid instruction ready (`fetch_valid_i`), and the execute stage is not waiting or stalled (`execute_waiting` is false), indicating the pipeline is progressing normally. Additionally, there must be no decode-to-execute pipeline halt (`decode_execute_halt` is false), no CPU-wide stall (`cpu_stall` is false), and either the processor is not in debug stepping mode or if stepping is active, it must be at an appropriate step (`stepping` with `pstep[1]` true). Together, these conditions mean the decode stage is actively passing a valid instruction to the execution pipeline, reflecting normal in-order instruction flow without pipeline stalls or debug intervention.

Test-Stimulus Guidance:  
To provoke this event in software, write sequences of instructions that execute without causing pipeline stalls or hazards, ensuring smooth in-order progression. Avoid introducing exceptions, debug breakpoints, or conditions that cause pipeline flushes or stalls. Typical user-level code with continuous instruction flow, such as arithmetic and logical operations in a loop, will cause the decode stage to validate instructions steadily. Avoid instructions that induce pipeline flushes (e.g., mispredicted branches or exceptions) or explicit debug stepping modes.

Instruction Categories:  
- Sequential non-branch instructions (arithmetic, logic, load/store) that do not cause pipeline stalls  
- Control flow instructions that are correctly predicted and do not trigger pipeline flushes  
- Instructions that do not trigger debug or exception events  
- Normal user-level instructions that keep the pipeline flowing without interrupting execution

Net: padv_execute_i

High-Level Event: The processor is actively executing an instruction in the execute stage without stalls, exceptions, or halts.

Logical Summary & Reasoning:  
This signal is asserted when the decode stage has a valid instruction ready to proceed, and the processor is not currently stalled or waiting in the execute stage. It ensures no exceptions are pending or taken, no halt signals are asserted, no special return-from-exception operations are in progress, and no debug-induced stalls or stepping conditions prevent execution. Essentially, it reflects the readiness and permission for the execute stage to perform its operation on a new instruction, indicating smooth forward progress of instruction execution.

Test-Stimulus Guidance:  
To provoke this event, software should execute a continuous stream of instructions without causing exceptions, pipeline stalls, or halt conditions. Avoid triggering exceptions, interrupts, or debug breakpoints. Instructions should not invoke return-from-exception operations or cause pipeline flushes. Simple arithmetic, logical, or memory instructions that do not cause hazards or exceptions will maintain this signal asserted, representing uninterrupted instruction execution.

Instruction Categories:  
- Normal arithmetic and logical instructions (e.g., add, sub, and, or)  
- Simple memory access instructions (loads and stores) without exceptions  
- Control flow instructions that do not generate exceptions or pipeline flushes  
- Instructions that do not trigger debug or stepping conditions  
- Non-exceptional instructions that do not cause pipeline stalls or halts

Net: pc_execute_i

High-Level Event: The program counter value is updated at instruction execution to reflect the current instructionâ€™s address.

Logical Summary & Reasoning:  
The signal pc_execute_i represents the program counter (PC) as seen in the execution stage of the pipeline. It originates from the fetch stage PC value, passing through decode, and is conditionally updated depending on pipeline conditions such as stalls or resets. The PC update logic incorporates branch predictions, exceptions, restarts, and reset conditions to select the correct address for execution. This signal is fundamentally the architectural PC value that identifies which instruction is currently being executed, thus enabling correct sequencing of instruction execution and precise control flow. It serves to track the instruction address at the first pipeline stage where instruction execution semantics are established.

Test-Stimulus Guidance:  
To influence this event, software can generate control flow changes such as branches, jumps, exceptions, and resets. Writing C code with conditional branches, function calls, returns, or exception-triggering operations will cause the program counter to update accordingly at execution time. For example, if-else statements, loops, and function invocations create new PC targets. Triggering exceptions (e.g., division by zero) or system calls that cause control flow redirection also provoke PC updates at execution. Additionally, software sequences that cause pipeline stalls or restarts will affect PC progression observable at execution.

Instruction Categories:  
Control flow instructions including branches (conditional and unconditional), jumps, calls, returns, and exception-generating instructions. Also includes instructions that cause pipeline restarts or flushes such as system calls, interrupts, or fault-triggering operations. Regular sequential instructions that advance PC normally are grouped as well, since their execution updates PC in order.

Net: pipeline_flush_i

High-Level Event: Pipeline flush triggered, discarding in-flight instructions and restarting fetch.

Logical Summary & Reasoning:  
The signal pipeline_flush_i activates when any of these conditions occur: a return-from-exception instruction is in progress, a new exception is recognized and needs handling, or the CPU enters a stall state (though stall is disabled here). This flush signal logically gates on the presence of an exception event, the execution of a special control flow instruction to return from exception, or a stall condition that requires discarding speculative or partial instructions in the pipeline. Its role is to clear partially executed instructions and restart instruction fetching to maintain correct program order and architectural state after disruptive events like exceptions or control flow changes.

Test-Stimulus Guidance:  
Software can provoke this event by causing exceptions (e.g., illegal instructions, memory access violations, system calls triggering traps), or by executing instructions that cause control flow changes such as return-from-exception (RFE) instructions. For example, generating a divide-by-zero, triggering page faults, or explicit software interrupts will provoke exceptions that cause pipeline flush. Similarly, exercising exception return instructions in privileged code paths will also cause pipeline flush.

Instruction Categories:  
- Exception-triggering instructions (illegal, syscall, trap, memory faults)  
- Control flow instructions for exception handling (return-from-exception, interrupt return)  
- Potentially instructions causing pipeline stalls or synchronization (though stall is disabled here)

Net: rfa_i

High-Level Event: The register file provides the operand value used by the executing instruction.

Logical Summary & Reasoning:  
The signal `rfa_i` reflects the operand data read from the register file for the current instruction in the execute stage. Its value is logically determined by selecting among several sources depending on pipeline hazards and forwarding conditions: it may come from the execute stageâ€™s forwarding result (to resolve data hazards), control hazard results (e.g., from branch or jump instructions), write-back stage forwarding, or directly from the register file read port if no hazards exist. This multiplexer logic ensures that the operand is the most recent and correct value visible to the instruction being executed, enabling correct and efficient in-order instruction execution without stalls when possible.

Test-Stimulus Guidance:  
To provoke this event, software should include instructions that consume register operands which may be recently updated by preceding instructions. Typical scenarios include sequences with data dependencies such as arithmetic or logical operations where the result of one instruction is immediately used by the next, or control flow instructions that update registers (e.g., jumps with link). Writing code with dependent instructions that read and write the same registers in close succession will exercise the forwarding and hazard resolution reflected in this signal.

Instruction Categories:  
- Arithmetic and Logical instructions (e.g., add, sub, and, or) that read register operands and produce results.  
- Control flow instructions that update registers (e.g., jump-and-link, call) affecting operand sourcing.  
- Load and Store instructions that may write to registers or use register operands for address calculation.  
- Instructions causing pipeline hazards requiring operand forwarding or hazard resolution.

Net: rfb_i

High-Level Event: Forwarding or bypassing of an instruction result to resolve data hazards during execution.

Logical Summary & Reasoning:  
The signal `rfb_i` reflects the value selected to be used as a forwarded operand or result in the execute stage of the pipeline. Its logic prioritizes resolving data hazards by selecting the most recent valid result from various pipeline stages: execution hazards, control hazards, or writeback hazards. If no hazards require forwarding, it defaults to the normal register file output. This mechanism ensures that instructions dependent on previous results can receive updated data without stalling, representing operand forwarding or bypassing at the architectural level to maintain in-order execution flow.

Test-Stimulus Guidance:  
Software can trigger this event by writing instructions where a subsequent instruction depends on the result of a prior instruction that has not yet completed writeback. For example, back-to-back arithmetic or logical instructions where the second uses the first's destination register as a source operand. Also, control flow changes like jumps or branches that depend on recent ALU results can provoke control hazard forwarding. Data dependencies across loads, stores, and arithmetic operations increase chances of operand forwarding to avoid pipeline stalls.

Instruction Categories:  
- Arithmetic and logical instructions producing results used by following instructions (e.g., add, sub, and, or)  
- Load and store instructions causing data hazards with dependent memory or register reads  
- Control flow instructions (e.g., jumps, branches) requiring recent ALU or condition evaluation results  
- Instructions writing to special registers or system registers that subsequent instructions may read

Net: shift_result

High-Level Event: Execution of a shift operation producing a shifted result value.

Logical Summary & Reasoning:  
The signal `shift_result` represents the output value of a shift operation executed during the instruction's arithmetic/logic stage. It is logically determined by whether a barrel shifter is implemented and the type of shift requested (e.g., logical left shift vs. right shift). The value is computed by shifting the input operand left or right by a specified amount, effectively performing bitwise shifting. This operation abstracts away the micro-architectural details of how shifting is performed internally and focuses on the conceptual transformation of operand bits as visible to software. The signal directly corresponds to the result of an instruction that modifies a register by shifting its bits.

Test-Stimulus Guidance:  
To provoke this event in software, write C code that uses shift instructions or shift operations, such as left shifts (`<<`), logical right shifts (`>>` on unsigned types), or arithmetic right shifts (preserving sign on signed types). Test cases can include shifting by variable amounts, shifting by zero, or shifting by the maximum bit width minus one. Use a combination of constants and register values as inputs to these operations. Additionally, testing with signed and unsigned data types can help exercise different shift semantics at the ISA level.

Instruction Categories:  
- Shift instructions (logical left shift, logical right shift, arithmetic right shift)  
- Bit manipulation instructions that include shifts as part of their operation  
- Arithmetic instructions that implicitly involve shifts (e.g., multiply by powers of two)  
- Instructions that update general-purpose registers with shifted values

Net: shift_valid

High-Level Event: Indication that a shift operation is valid and ready for execution in the ALU stage.

Logical Summary & Reasoning: The signal shift_valid reflects whether the current instruction involves a shift operation that the processor can execute. It is logically determined by the presence of a shift-type instruction being decoded or executed. In architectures with a barrel shifter, this signal is asserted directly, indicating the hardwareâ€™s readiness to perform the shift operation in the ALU stage. Otherwise, it depends on a condition tied to the instructionâ€™s destination validity, signaling that a shift operation result is expected. This signal gates the execution of shift instructions and ensures they proceed through the pipeline correctly.

Test-Stimulus Guidance: To provoke this event, software should include instructions performing shift operations such as logical shifts, arithmetic shifts, or rotates. Typical examples include left or right shifts on integer registers, which can be induced by C code using bitwise shift operators (<<, >>) on integer variables. Using shifts on variables in expressions or assignments will trigger this event.

Instruction Categories: Shift instructions, including logical shift left/right, arithmetic shift right, and rotate operations that manipulate register values through bitwise shifting. These are typically categorized under bitwise or data manipulation instructions.

